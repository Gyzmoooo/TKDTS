Slave riceve START:
collectSensorDataClient() chiamato in loop(). Misurazione per misurazione, i dati vengono inseriti in accumulatedDataLocal. accumulatedDataLocal è una stringa, e quindi pesa 6 + n byte, dove n è il numero di caratteri della stringa.

L'oggetto String può (punto 5. di https://gemini.google.com/app/1284c82410425d00) frammentare la SRAM su cui sono salvati i dati del programma. Quando quindi si fanno registrazioni molto lunghe, questo renderebbe impossibile la ricerca di blocchi di memoria contigui. 

Slave riceve STOP:
Viene chiamata sendDataToMaster(). Viene mandata accumulatedDataLocal al Master con una richiesta POST. Il Master gestisce la richiesta POST con handelSubmit()

I dati mandati dallo Slave sono salvati nella String clientData e successivamente nelle String accumulatedData_ESP2, accumulatedData_ESP3 e accumulatedData_ESP4. I dati del Master sono stati registrati sulla String accumulatedData_ESP1.

Gli accumulatedData di ciascun ESP vengono inseriti nella String aggregatedData, che viene mandata in risposta alla richiesta GET del computer quando il bottone è stato premuto per la seconda volta.



La mia ipotesi è che quando i dati mandati dallo Slave giungono al Master con la richiesta POST, questi non trovano spazio nella SRAM del Master, piena e potenzialmente frammentata dalla String accumulatedData_ESP1.


C'è un problema di alimentazione, quando una scheda Slave non è alimentata bene (la tensione è minore di quella necessaria per alimentare il sensore) i dati neanche arrivano al Master.



Anche durante le lunghe registrazioni, i dati vengono presi (il led blu rimane sempre acceso) e vengono salvati nelle String corrispondenti.

Quando ci sono troppi dati, handleSubmit() non viene neanche chiamata: Gli Slave non mandano la richiesta? Il Master non la riceve?

Viene chiamata sendDataToMaster(), viene mandata la richiesta con http.POST(accumulatedDataLocal), lo Slave non riceve risposta dal Master.

[HTTP] Invio POST fallito, errore HTTPClient: send payload failed

Questo è l'errore printato dallo Slave sulla seriale. Potrebbe essere causato o dall'eccessiva grandezza dei dati (payload) oppure da un timeout del client HTTP troppo basso.

--------------------------------------------------------------------------------------------------------------------------------

Sto modificando il Master in modo tale da aggiungere gli End marker (righe 187 e 144). Una volta sistemato, si potrà eliminare la funzione correct() nel main.py


Va implementato il sistema di divisione e quello che usa i led per confermare l'invio dei dati da parte degli slave

--------------------------------------------------------------------------------------------------------------------------------
Sto provando a vedere per quanto tempo gli SmartStraps riescono a mandare dati a 100Hz perché secondo Gemini è una frequenza più adatta a misurare un calcio.

Se funzionasse per più di 30 secondi, potrei pensare di riprendere tutti i dati per far funzionare il modello a 100 Hz. Se non ci riescono, devo trovare un valore adatto per il filtro passa basso.

Una volta trovato il valore del filtro passa basso, bisogna capire se posso applicare il filtro ai dati che ho già preso che ho usato per allenare il modello. Se si può fare allora bisogna riconvertire i dataset (sia quello di classificazione che quello kicksplit), verificare che il modello di classificazione allenato su dati a cui sono stati applicati i filtri funzioni su misurazioni prese in tempo reale corrette con il filtro passa basso, e infine comparare il taglio di misurazioni lunghe fatto con il modello kicksplit e con un algoritmo di thresholding applicato all'SMV. Se nessuno dei due da risultati soddisfacenti, si potrebbe tentare con un HMM, un Hidden Markov Model, in cui i diversi stati vengono determinati a partire dall'SMV.













