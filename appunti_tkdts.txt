Slave riceve START:
collectSensorDataClient() chiamato in loop(). Misurazione per misurazione, i dati vengono inseriti in accumulatedDataLocal. accumulatedDataLocal è una stringa, e quindi pesa 6 + n byte, dove n è il numero di caratteri della stringa.

L'oggetto String può (punto 5. di https://gemini.google.com/app/1284c82410425d00) frammentare la SRAM su cui sono salvati i dati del programma. Quando quindi si fanno registrazioni molto lunghe, questo renderebbe impossibile la ricerca di blocchi di memoria contigui. 

Slave riceve STOP:
Viene chiamata sendDataToMaster(). Viene mandata accumulatedDataLocal al Master con una richiesta POST. Il Master gestisce la richiesta POST con handelSubmit()

I dati mandati dallo Slave sono salvati nella String clientData e successivamente nelle String accumulatedData_ESP2, accumulatedData_ESP3 e accumulatedData_ESP4. I dati del Master sono stati registrati sulla String accumulatedData_ESP1.

Gli accumulatedData di ciascun ESP vengono inseriti nella String aggregatedData, che viene mandata in risposta alla richiesta GET del computer quando il bottone è stato premuto per la seconda volta.



La mia ipotesi è che quando i dati mandati dallo Slave giungono al Master con la richiesta POST, questi non trovano spazio nella SRAM del Master, piena e potenzialmente frammentata dalla String accumulatedData_ESP1.


C'è un problema di alimentazione, quando una scheda Slave non è alimentata bene (la tensione è minore di quella necessaria per alimentare il sensore) i dati neanche arrivano al Master.



Anche durante le lunghe registrazioni, i dati vengono presi (il led blu rimane sempre acceso) e vengono salvati nelle String corrispondenti.

Quando ci sono troppi dati, handleSubmit() non viene neanche chiamata: Gli Slave non mandano la richiesta? Il Master non la riceve?

Viene chiamata sendDataToMaster(), viene mandata la richiesta con http.POST(accumulatedDataLocal), lo Slave non riceve risposta dal Master.

[HTTP] Invio POST fallito, errore HTTPClient: send payload failed

Questo è l'errore printato dallo Slave sulla seriale. Potrebbe essere causato o dall'eccessiva grandezza dei dati (payload) oppure da un timeout del client HTTP troppo basso.